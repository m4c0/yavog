#version 450
#pragma leco include "quaternions.glsl"

struct inst {
  vec4 rot;
  vec4 pos;  // pos.xyz + mdl
  vec4 size; // size.xyz + txt
};

layout(constant_id = 99) const int k_len = 31;

layout(push_constant) uniform upc {
  uvec3 n;
} pc;

layout(binding = 0, set = 0) readonly buffer buf_0 { inst from[]; };
layout(binding = 0, set = 1) buffer buf_1 { inst to[]; };

vec3 qrot(vec3 p, vec4 q);

bool valid(inst aa) {
  if (aa.pos.w == 2) return true; // Cube is always fine

  if (aa.pos.w == 3) { // Prism only on Z
    vec3 r = qrot(pc.n, aa.rot);
    return length(abs(r) - vec3(0, 0, 1)) < 0.001;
  }

  return false;
}
bool same(inst aa, uint b) {
  inst bb = from[b];
  return
    length(aa.rot - bb.rot) < 0.001 &&
    length(aa.size - bb.size) < 0.001 &&
    abs(aa.pos.w - bb.pos.w) < 0.001;
}
uint idx(uvec3 p) {
  return p.x + p.y * k_len + p.z * k_len * k_len;
}

void main() {
  uint tgt = idx(gl_GlobalInvocationID);
  inst orig = to[tgt] = from[tgt];
  for (int i = 1; i < k_len; i++) { 
    uint nxt = idx(gl_GlobalInvocationID + pc.n * i);
    if (valid(orig) && same(orig, nxt)) {
      to[tgt].pos.xyz += 0.5 * pc.n;
      to[tgt].size.xyz += 1.0 * pc.n;
      to[nxt] = inst(vec4(0), vec4(0), vec4(0));
    } else {
      tgt = nxt;
      orig = to[tgt] = from[tgt];
    }
  }
}
