#version 450

struct inst {
  vec4 rot;
  vec4 pos;  // pos.xyz + mdl
  vec4 size; // size.xyz + txt
};

layout(constant_id = 0) const int k_len = 31;

layout(binding = 0) readonly buffer buf_0 {
  inst host[];
};
layout(binding = 1) buffer buf_1 {
  inst local[];
};

bool same(uint a, uint b) {
  inst aa = host[a];
  inst bb = host[b];
  return
    length(aa.rot - bb.rot) < 0.001 &&
    length(aa.size - bb.size) < 0.001 &&
    abs(aa.pos.w - bb.pos.w) < 0.001;
}
uint idx(uvec3 i) {
  uvec3 p = i + gl_GlobalInvocationID;
  return p.x + p.y * k_len + p.z * k_len * k_len;
}
uvec3 merge(uvec3 a3, uvec3 b3, uint n) {
  uint a = idx(a3);
  uint b = idx(b3 * n);
  if (same(a, b)) {
    local[a].pos.xyz += 0.5 * b3;
    local[a].size.xyz += 1.0 * b3;
    local[b].pos.w = 0;
    return a3;
  } else {
    return b3 * n;
  }
}

void copy() {
  for (int z = 0; z < k_len; z++) { 
    local[idx(uvec3(0, 0, z))] = host[idx(uvec3(0, 0, z))];
  }
}

void compact_z() {
  uvec3 tgt = uvec3(0);
  for (int z = 1; z < k_len; z++) { 
    tgt = merge(tgt, uvec3(0, 0, 1), z);
  }
}

void compact_y() {
  uvec3 tgt = uvec3(0);
  for (int y = 1; y < k_len; y++) { 
    tgt = merge(tgt, uvec3(0, 1, 0), y);
  }
}

void compact_x() {
  uvec3 tgt = uvec3(0);
  for (int x = 1; x < k_len; x++) { 
    tgt = merge(tgt, uvec3(1, 0, 0), x);
  }
}

// TODO: filter compacts by model (ex: prism only in Z, etc)
void main() {
  copy();
  compact_z();
  barrier();
  compact_y();
  barrier();
  compact_x();
}
